# Разные алгоритмы в Java / Java_Algorithm
___Это проект реализации различных алгоритмов:___
1. Поиск минимального значения в массиве / Minimum_value_in_array 
2. Сортировка пузырьком / Bubble_sort 
3. Алгоритм поиска в папках всех картинок / File_Search 
4. Сортировка массива выбором / Sorting_by_choice [^4]
5. Быстрая сортировка / Quick_Sort [^5]
6. Сортировка слиянием / Merge_Sort [^6]
7. Линейный поиск / Linear_Search [^7]
8. Двоичный (Бинарный) поиск / Binary_Search [^8]
9. Бинарное дерево (Рекурсивный обход в глубину) Алгоритм DFS («Depth-first search» / Depth_First_Search [^9]
10. Очередь и стэк / stack_and_queue [^10]
11. Продолжение бинарного дерева и поиск в глубину и ширину / SumDeep_SumWide_Tree2[^11]
12. Поиск второго по минимальности элемента в массиве / Search_Second_Min_Element[^12]
13. 




[^4]: Sorting_by_choice - использует в себе поиск минимального элемента в массиве и ставит его в начало. На каждом шаге область отсортированных элементов увеличивается (step сдвигается).
[^5]: Quick_Sort - основная логика заключается в том, что выбирается опорный элемент, те которые меньше него идут влево, те которые больше идут вправо. После выбирается опорные элементы у этих массивов и так далее, до того момента пока эти подмассивы не превратятся в отдельные элементы. (Алгоритм быстрой сортировки неплохо работает с кэшом на современных процессорах) (На каждой итерации всё уменьшается. Так как подмассивы сортируются независимо друг от друга. Процесс их сортировки можно делать параллельно. И можно пременить вместо быстрой сортировки, какую-нибудь другую).
[^6]: Merge_Sort - Сортировка слиянием также как и быстрая сортировка основанна на принципе разделяй и властвуй. Если быстрая сортировка от большого массива разделяет его и идет к более меньшим массивам (подмассива) а далее к элементам, то сортировка слиянием сначала разбивает весь массив на элементы, а позже соединяет их в отсортированном порядке. ![image](https://user-images.githubusercontent.com/35079479/146191035-bdee7459-867d-4d6e-906a-0aa1826e34b3.png)
![image](https://user-images.githubusercontent.com/35079479/146193112-6bb12ad0-03c4-476d-b84f-9d1ac4522225.png)
[^7]: Linear_Search - Проходит по каждому элементу в массиве (медленный)
[^8]: Binary_Search - Делит массив на две части и сравнивает исковый элемент с серединой, после чего выбирает левый или правый массив. МАССИВ ДОЛЖЕН БЫТЬ ОТСОРТИРОВАННЫМ! Можно реализовать с помощью рекурсии. ![image](https://user-images.githubusercontent.com/35079479/146417618-5790fd18-ad1a-45db-a290-5818920b5a48.png)
 ![image](https://user-images.githubusercontent.com/35079479/146413871-1c5950dd-aa1d-4534-a131-00fb3b46e0e1.png)
[^9]: Depth_First_Search - это рекурсивный обход дерева в глубину. Алгорит идет максимально в глубину по левой стороне. ![image](https://user-images.githubusercontent.com/35079479/146454556-86eb56ce-22c1-47f7-8442-c58c177b9f06.png) ![image](https://user-images.githubusercontent.com/35079479/146456063-056f39d5-4e5f-4f2d-a919-3adc6c5b5ef3.png)
[^10]: stack_and_queue - очередь и стэк могут быть основаны на любой коллекции. нам важен интерфейс а не структура. ![image](https://user-images.githubusercontent.com/35079479/146604684-70e30efd-0f5e-411f-98a2-ea34d31bf8d6.png)
![image](https://user-images.githubusercontent.com/35079479/146605905-59e42dd1-0ca5-4cfa-8c4e-b906dfaeb4c1.png)
Основной функцией очереди является создание асинхронного взаимодействия с элементами. Объект А взаимодействуют с очередью в начале и кладет туда элементы со своей скоростью. Объект B работает с очередью в конце со своей скоростью. (Поэтому очередь помогает сглаживать пиковые нагрузки(Когда будет передышка потребитель данных успеет обработать всю очередь))(Также нужно сказать, что очередь запаминает последовательность выполнения задач включенных в нее)(Очередь может хранить данных и при выключенния приложения)(Бывает также блокирующая очередь. если она переполнена она не включает новые элементы) ![image](https://user-images.githubusercontent.com/35079479/146606656-b5f0d7eb-1627-4c03-9512-d28489871989.png)![image](https://user-images.githubusercontent.com/35079479/146606787-d0a62e3a-05d5-4ce5-ae80-ff7eaab6b03e.png)
[^11]: SumDeep_SumWide_Tree2 - поиск в глубину основан на стэке, поиск в ширину основан на очереди. Алгоритм один и тот же различие только в том какую структуру данных использовать.
[^12]: Search_Second_Min_Element - Алгоритм похож на поиск минимального элемента, только тут ещё запоминается предыдущий минимальный элемент.

